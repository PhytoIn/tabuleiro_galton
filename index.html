<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tabuleiro de Galton</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      padding: 10px;
      background-color: #f7f5f2;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: #5a5a5a;
      min-height: 100vh;
      width: 100%;
    }
    
    h1 {
      color: #7a6c5d;
      margin: 15px 0;
      font-weight: 300;
      font-size: calc(1.5rem + 1vw);
      text-align: center;
    }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 15px;
      width: 100%;
      max-width: 600px;
    }
    
    .control-group {
      display: flex;
      flex-direction: column;
      background-color: #fff;
      padding: 10px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      flex: 1;
      min-width: 120px;
    }
    
    label {
      font-weight: 600;
      margin-bottom: 8px;
      color: #7a6c5d;
      font-size: 0.9rem;
    }
    
    input[type="number"] {
      padding: 8px;
      border: 2px solid #e6e0d8;
      border-radius: 8px;
      font-size: 1rem;
      width: 100%;
      box-sizing: border-box;
      color: #5a5a5a;
    }
    
    input[type="range"] {
      width: 100%;
      margin-top: 8px;
      accent-color: #bc9f77;
    }
    
    .button-container {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    button {
      padding: 10px 15px;
      border: none;
      border-radius: 12px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      background-color: #bc9f77;
      color: white;
      flex: 1;
      min-width: 120px;
      max-width: 200px;
    }
    
    button:hover {
      background-color: #a88a62;
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    .board-container {
      position: relative;
      width: 100%;
      max-width: 600px;
      aspect-ratio: 3/4;
      background-color: #fff;
      border-radius: 16px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.08);
      border: 6px solid #d8c4a9;
      overflow: hidden;
      margin-bottom: 15px;
    }
    
    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    
    .side-panel {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 15px;
      background-color: #d8c4a9;
    }
    
    .left-panel {
      left: 0;
    }
    
    .right-panel {
      right: 0;
    }
    
    .footer {
      text-align: center;
      margin-top: 5px;
      font-size: 16px;
      color: #7a6c5d;
      font-weight: 500;
      width: 100%;
      padding: 10px;
    }
    
    .chi2-result {
      width: 100%;
      max-width: 600px;
      text-align: center;
      font-size: 0.95rem;
      color: #5a5a5a;
      min-height: 0;
      transition: all 0.3s ease;
    }
    
    .chi2-result.visible {
      background-color: #fff;
      padding: 14px 18px;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.05);
      margin-bottom: 10px;
    }
    
    .chi2-result .chi2-title {
      font-weight: 600;
      color: #7a6c5d;
      margin-bottom: 6px;
      font-size: 1rem;
    }
    
    .chi2-result .chi2-values {
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9rem;
      line-height: 1.6;
    }
    
    .chi2-result .chi2-interpretation {
      margin-top: 8px;
      font-style: italic;
      font-size: 0.85rem;
      color: #7a6c5d;
    }
    
    @media (max-width: 480px) {
      .control-group {
        min-width: 100%;
      }
      
      button {
        min-width: 45%;
      }
      
      h1 {
        font-size: 1.5rem;
      }
      
      .board-container {
        border-width: 4px;
      }
      
      .side-panel {
        width: 10px;
      }
    }
  </style>
</head>
<body>
  <h1>Tabuleiro de Galton</h1>
  
  <div class="controls">
    <div class="control-group">
      <label for="rows">Número de linhas:</label>
      <input type="number" id="rows" min="1" max="20" value="20">
    </div>
    
    <div class="control-group">
      <label for="balls">Número de bolinhas:</label>
      <input type="number" id="balls" min="1" max="10000" value="200">
    </div>
    
    <div class="control-group">
      <label for="speed">Velocidade:</label>
      <input type="range" id="speed" min="0.5" max="5" step="0.1" value="5">
    </div>
  </div>
  
  <div class="button-container">
    <button id="generate">Gerar Tabuleiro</button>
    <button id="start">Iniciar Simulação</button>
  </div>
  
  <div class="board-container">
    <div class="side-panel left-panel"></div>
    <canvas id="canvas"></canvas>
    <div class="side-panel right-panel"></div>
  </div>
  
  <div id="chi2-result" class="chi2-result"></div>
  
  <div class="footer">
    <p>© (2026) Rodrigo Pereira</p>
  </div>
  
  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const rowsInput = document.getElementById('rows');
    const ballsInput = document.getElementById('balls');
    const speedInput = document.getElementById('speed');
    let rows, width, height;
    let finishedCounts = [];
    let finishedBalls = [];
    let totalBalls = 0;
    let currentBall = 0;
    let activeBalls = [];
    let droppedBalls = 0;
    let spawnTimer;
    let pegPositions = [];
    let columnPositions = [];
    let simulationFinished = false;
    
    let PEG_RADIUS = 4.2;
    
    function resizeCanvas() {
      const container = canvas.parentElement;
      const dpr = window.devicePixelRatio || 1;
      const cssWidth = container.clientWidth;
      const cssHeight = container.clientHeight;
      
      // Definir tamanho real do canvas (alta resolução)
      canvas.width = cssWidth * dpr;
      canvas.height = cssHeight * dpr;
      
      // Manter tamanho CSS original
      canvas.style.width = cssWidth + 'px';
      canvas.style.height = cssHeight + 'px';
      
      // Escalar o contexto para desenhar em coordenadas CSS
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      
      width = cssWidth;
      height = cssHeight;
      
      // PEG_RADIUS proporcional ao tamanho do tabuleiro
      PEG_RADIUS = Math.max(2, width / 140);
      
      if (rows) {
        calculatePositions();
        drawBoardStructure();
        drawHistogram();
        // Redesenhar curva se a simulação já terminou
        if (simulationFinished) {
          drawBinomialCurve();
        }
      }
    }
    
    function initCanvas() {
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
    }
    
    // [ALTERAÇÃO 1] Cores mais vibrantes e saturadas para as bolinhas
    const colors = {
      background: '#f2ebdf',
      peg: '#bc9f77',
      pegBorder: '#a88a62',
      ballColors: ['#3da8b8', '#c46b8a', '#8b7ec8', '#4a8fbf', '#e07850'],
      binomialCurve: '#7a6c5d',
      divider: '#d8c4a9'
    };

    function binomial(n, k) {
      if (k < 0 || k > n) return 0;
      let coeff = 1;
      for (let i = 1; i <= k; i++) {
        coeff *= (n - (k - i));
        coeff /= i;
      }
      return coeff;
    }
    
    // [ALTERAÇÃO 3] Função para calcular o raio das bolinhas proporcionalmente à largura da coluna
    function getBallRadius() {
      const columnWidth = width / (rows + 1);
      // Diâmetro de 2 bolinhas = largura da coluna → raio = coluna / 4
      // Pequena margem para não encostar nas paredes
      return columnWidth / 4.2;
    }
    
    function calculatePositions() {
      rows = parseInt(rowsInput.value, 10);
      const pegAreaHeight = height * 0.6;
      const vSpacing = pegAreaHeight / (rows + 1);
      const numColumns = rows + 1;
      const columnWidth = width / numColumns;
      
      columnPositions = [];
      for (let i = 0; i <= numColumns; i++) {
        columnPositions.push(i * columnWidth);
      }
      
      pegPositions = [];
      for (let i = 0; i < rows; i++) {
        const rowPegs = i + 1;
        const pegRow = [];
        const startX = (width - (rowPegs - 1) * columnWidth) / 2;
        for (let j = 0; j < rowPegs; j++) {
          pegRow.push(startX + j * columnWidth);
        }
        pegPositions.push({
          y: vSpacing * (i + 1),
          xPositions: pegRow
        });
      }
    }

    function drawBoardStructure() {
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      if (pegPositions.length === 0) {
        calculatePositions();
      }
      
      const pegAreaHeight = height * 0.6;
      
      for (let i = 0; i < pegPositions.length; i++) {
        const row = pegPositions[i];
        const y = row.y;
        
        for (let j = 0; j < row.xPositions.length; j++) {
          const x = row.xPositions[j];
          
          ctx.fillStyle = 'rgba(0,0,0,0.1)';
          ctx.beginPath();
          ctx.arc(x + 1.5, y + 1.5, PEG_RADIUS, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.fillStyle = colors.peg;
          ctx.beginPath();
          ctx.arc(x, y, PEG_RADIUS, 0, 2 * Math.PI);
          ctx.fill();
          
          ctx.strokeStyle = colors.pegBorder;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(x, y, PEG_RADIUS, 0, 2 * Math.PI);
          ctx.stroke();
        }
      }
      
      ctx.strokeStyle = colors.divider;
      ctx.lineWidth = 3;
      
      for (let i = 0; i < columnPositions.length; i++) {
        const x = columnPositions[i];
        ctx.beginPath();
        ctx.moveTo(x, pegAreaHeight);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
    }

    // Função auxiliar para desenhar uma bolinha com efeito 3D
    function drawBall(x, y, radius, color) {
      // Sombra
      ctx.fillStyle = 'rgba(0,0,0,0.15)';
      ctx.beginPath();
      ctx.arc(x + 1, y + 1, radius, 0, 2 * Math.PI);
      ctx.fill();
      
      // Corpo
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
      
      // Brilho
      ctx.fillStyle = 'rgba(255,255,255,0.45)';
      ctx.beginPath();
      ctx.arc(x - radius * 0.3, y - radius * 0.3, radius * 0.35, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawHistogram() {
      if (columnPositions.length === 0) return;
      
      const pegAreaHeight = height * 0.6;
      const columnWidth = width / (rows + 1);
      const ballRadius = getBallRadius();
      const ballDiameter = ballRadius * 2;
      const ballsPerRow = 2;
      
      for (let bin = 0; bin < finishedBalls.length; bin++) {
        const balls = finishedBalls[bin];
        if (!balls) continue;
        
        const binX = bin * columnWidth;
        const binCenterX = binX + columnWidth / 2;
        
        for (let i = 0; i < balls.length; i++) {
          const ball = balls[i];
          // Só desenhar bolinhas que já terminaram de cair (sem targetY ou já chegaram)
          if (ball.currentY === undefined) ball.currentY = ball.finalY;
          
          const row = Math.floor(i / ballsPerRow);
          const col = i % ballsPerRow;
          
          // Posicionar 2 bolinhas lado a lado centralizadas na coluna
          const xOffset = (col === 0) ? -ballRadius : ballRadius;
          const x = binCenterX + xOffset;
          const y = ball.currentY;
          
          if (y < pegAreaHeight + 6) continue;
          
          drawBall(x, y, ballRadius, ball.color);
        }
      }
    }

    // [ALTERAÇÃO 4] Curva suave usando interpolação spline (Catmull-Rom)
    // Escala baseada no máximo teórico, considerando o tamanho físico das bolinhas
    function drawBinomialCurve() {
      const pegAreaHeight = height * 0.6;
      const binAreaStart = pegAreaHeight + 6;
      const binAreaHeight = height - binAreaStart;
      const binCount = rows + 1;
      const columnWidth = width / binCount;
      const ballRadius = getBallRadius();
      const ballDiameter = ballRadius * 2;
      const p = 0.5;
      const pmf = [];
      
      for (let k = 0; k <= rows; k++) {
        pmf.push(binomial(rows, k) * Math.pow(p, k) * Math.pow(1 - p, rows - k));
      }
      
      // Máximo teórico esperado (contagem de bolinhas no bin mais cheio)
      const maxPmf = Math.max(...pmf);
      const maxExpectedCount = maxPmf * totalBalls;
      
      // Converter contagem em altura física: 2 bolinhas por linha,
      // cada linha ocupa 1 diâmetro de altura
      // Número de linhas para uma contagem N = ceil(N / 2)
      // Altura em pixels = ceil(N / 2) * ballDiameter
      // Para a curva, usamos a versão contínua: (N / 2) * ballDiameter
      const maxExpectedHeight = (maxExpectedCount / 2) * ballDiameter;
      
      // Se a altura teórica excede a área disponível, aplicar um fator de compressão
      const availableHeight = binAreaHeight * 0.95;
      const compressionFactor = maxExpectedHeight > availableHeight 
        ? availableHeight / maxExpectedHeight 
        : 1.0;
      
      // Gerar pontos da curva
      const points = [];
      for (let k = 0; k <= rows; k++) {
        const xCenter = k * columnWidth + columnWidth / 2;
        const expectedCount = pmf[k] * totalBalls;
        // Altura em pixels proporcional ao tamanho das bolinhas
        const expectedHeight = (expectedCount / 2) * ballDiameter * compressionFactor;
        const yCurve = height - expectedHeight;
        const safeY = Math.max(binAreaStart, Math.min(height, yCurve));
        points.push({ x: xCenter, y: safeY });
      }
      
      if (points.length < 2) return;
      
      // Desenhar curva suave usando Catmull-Rom spline convertido para Bézier
      ctx.strokeStyle = colors.binomialCurve;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      
      for (let i = 0; i < points.length - 1; i++) {
        const p0 = points[Math.max(i - 1, 0)];
        const p1 = points[i];
        const p2 = points[i + 1];
        const p3 = points[Math.min(i + 2, points.length - 1)];
        
        const tension = 6;
        const cp1x = p1.x + (p2.x - p0.x) / tension;
        const cp1y = p1.y + (p2.y - p0.y) / tension;
        const cp2x = p2.x - (p3.x - p1.x) / tension;
        const cp2y = p2.y - (p3.y - p1.y) / tension;
        
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
      }
      
      ctx.stroke();
    }

    // ===== TESTE QUI-QUADRADO DE ADERÊNCIA =====
    
    // Função gama logarítmica (aproximação de Lanczos)
    function lnGamma(z) {
      const g = 7;
      const c = [
        0.99999999999980993, 676.5203681218851, -1259.1392167224028,
        771.32342877765313, -176.61502916214059, 12.507343278686905,
        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7
      ];
      if (z < 0.5) {
        return Math.log(Math.PI / Math.sin(Math.PI * z)) - lnGamma(1 - z);
      }
      z -= 1;
      let x = c[0];
      for (let i = 1; i < g + 2; i++) {
        x += c[i] / (z + i);
      }
      const t = z + g + 0.5;
      return 0.5 * Math.log(2 * Math.PI) + (z + 0.5) * Math.log(t) - t + Math.log(x);
    }

// Função gama incompleta inferior regularizada P(a, x)
function gammainc(a, x) {
  if (x < 0) return 0;
  if (x === 0) return 0;

  // Para x < a+1, usar expansão em série (converge bem nesta região)
  if (x < a + 1) {
    let sum = 1.0 / a;
    let term = 1.0 / a;
    for (let n = 1; n < 300; n++) {
      term *= x / (a + n);
      sum += term;
      if (Math.abs(term) < Math.abs(sum) * 1e-14) break;
    }
    return sum * Math.exp(-x + a * Math.log(x) - lnGamma(a));
  }

  // Para x >= a+1, calcular Q(a,x) via fração continuada (Legendre) e retornar P = 1 - Q
  const TINY = 1e-300;
  let b = x + 1 - a;
  let f = (Math.abs(b) < TINY) ? TINY : b;
  let C = f;
  let D = 0;

  for (let i = 1; i < 300; i++) {
    const ai = -i * (i - a);
    const bi = x + 2 * i + 1 - a;

    D = bi + ai * D;
    if (Math.abs(D) < TINY) D = TINY;
    D = 1.0 / D;

    C = bi + ai / C;
    if (Math.abs(C) < TINY) C = TINY;

    const delta = C * D;
    f *= delta;

    if (Math.abs(delta - 1.0) < 1e-14) break;
  }

  const Q = Math.exp(-x + a * Math.log(x) - lnGamma(a)) / f;
  return 1.0 - Q;
}

// Função gama incompleta superior regularizada Q(a, x) = 1 - P(a, x)
// Implementada para evitar cancelamento numérico ao calcular caudas pequenas.
function gammaincc(a, x) {
  if (x < 0) return 1;
  if (x === 0) return 1;

  // Para x < a+1, P(a,x) é estável via série; então Q = 1 - P.
  if (x < a + 1) {
    let sum = 1.0 / a;
    let term = 1.0 / a;
    for (let n = 1; n < 300; n++) {
      term *= x / (a + n);
      sum += term;
      if (Math.abs(term) < Math.abs(sum) * 1e-14) break;
    }
    const P = sum * Math.exp(-x + a * Math.log(x) - lnGamma(a));
    return 1.0 - P;
  }

  // Para x >= a+1, calcular Q(a,x) diretamente via fração continuada (Legendre)
  const TINY = 1e-300;
  let b = x + 1 - a;
  let f = (Math.abs(b) < TINY) ? TINY : b;
  let C = f;
  let D = 0;

  for (let i = 1; i < 300; i++) {
    const ai = -i * (i - a);
    const bi = x + 2 * i + 1 - a;

    D = bi + ai * D;
    if (Math.abs(D) < TINY) D = TINY;
    D = 1.0 / D;

    C = bi + ai / C;
    if (Math.abs(C) < TINY) C = TINY;

    const delta = C * D;
    f *= delta;

    if (Math.abs(delta - 1.0) < 1e-14) break;
  }

  return Math.exp(-x + a * Math.log(x) - lnGamma(a)) / f;
}

// P-valor do teste qui-quadrado: P(X² >= chi2obs) = Q(df/2, chi2obs/2)
function chi2pValue(chi2, df) {
  if (df <= 0) return 1;
  return gammaincc(df / 2, chi2 / 2);
}
// Executar o teste qui-quadrado e exibir resultados
    function runChiSquaredTest() {
      const binCount = rows + 1;
      const p = 0.5;
      
      // Calcular PMF binomial
      const pmf = [];
      for (let k = 0; k <= rows; k++) {
        pmf.push(binomial(rows, k) * Math.pow(p, k) * Math.pow(1 - p, rows - k));
      }
      
      // Contagens observadas
      const observed = [];
      for (let k = 0; k < binCount; k++) {
        observed.push(finishedBalls[k] ? finishedBalls[k].length : 0);
      }
      
      // Contagens esperadas
      const expected = pmf.map(pk => pk * totalBalls);
      
      
// Calcular estatística qui-quadrado (com agrupamento de caudas quando E < 5)
let chi2 = 0;
let lowExpectedCount = 0;

for (let k = 0; k < binCount; k++) {
  if (expected[k] < 5) {
    lowExpectedCount++;
  }
}

// Agrupar automaticamente caudas para reduzir instabilidade quando E é muito pequeno
const MIN_E = 5;
let left = 0;
let right = binCount - 1;

let leftObs = 0, leftExp = 0, leftUsed = 0;
if (expected[left] < MIN_E) {
  while (left <= right && leftExp < MIN_E) {
    leftObs += observed[left];
    leftExp += expected[left];
    leftUsed++;
    left++;
  }
}

let rightObs = 0, rightExp = 0, rightUsed = 0;
if (right >= left && expected[right] < MIN_E) {
  while (right >= left && rightExp < MIN_E) {
    rightObs += observed[right];
    rightExp += expected[right];
    rightUsed++;
    right--;
  }
}

const groupedObs = [];
const groupedExp = [];

// Se houve sobreposição (todas as classes acabaram agrupadas), usar um único grupo
if (left > right) {
  const obsSum = leftObs + rightObs;
  const expSum = leftExp + rightExp;
  if (expSum > 0) {
    groupedObs.push(obsSum);
    groupedExp.push(expSum);
  }
} else {
  if (leftUsed > 0) {
    groupedObs.push(leftObs);
    groupedExp.push(leftExp);
  }

  for (let k = left; k <= right; k++) {
    groupedObs.push(observed[k]);
    groupedExp.push(expected[k]);
  }

  if (rightUsed > 0) {
    groupedObs.push(rightObs);
    groupedExp.push(rightExp);
  }
}

// Estatística χ² nos grupos
for (let i = 0; i < groupedObs.length; i++) {
  if (groupedExp[i] > 0) {
    chi2 += Math.pow(groupedObs[i] - groupedExp[i], 2) / groupedExp[i];
  }
}

let df = groupedObs.length - 1; // graus de liberdade = grupos - 1

// Calcular p-valor
const pValue = chi2pValue(chi2, df);
// Exibir resultados
      const resultDiv = document.getElementById('chi2-result');
      resultDiv.className = 'chi2-result visible';
      
      let interpretation = '';
      if (pValue >= 0.05) {
        interpretation = 'Não há evidência para rejeitar a hipótese de aderência à distribuição binomial (p ≥ 0,05).';
      } else if (pValue >= 0.01) {
        interpretation = 'Evidência moderada contra a aderência à distribuição binomial (0,01 ≤ p < 0,05).';
      } else {
        interpretation = 'Evidência forte contra a aderência à distribuição binomial (p < 0,01).';
      }
      
      let warningText = '';
      if (lowExpectedCount > 0) {
                warningText = `<div style="margin-top:6px; font-size:0.82rem; color:#b8860b;">⚠ ${lowExpectedCount} de ${binCount} classes com frequência esperada &lt; 5. Caudas foram agrupadas para o cálculo de χ²; resultados ainda podem ser imprecisos.</div>`;
      }
      
      resultDiv.innerHTML = `
        <div class="chi2-title">Teste χ² de aderência</div>
        <div class="chi2-values">
          χ² = ${chi2.toFixed(4)} &nbsp;|&nbsp; gl = ${df} &nbsp;|&nbsp; p = ${pValue < 0.0001 ? pValue.toExponential(2) : pValue.toFixed(4)}
        </div>
        <div class="chi2-interpretation">${interpretation}</div>
        ${warningText}
      `;
    }
    // ===== FIM DO TESTE QUI-QUADRADO =====

    function generateBall() {
      const numColumns = rows + 1;
      const columnWidth = width / numColumns;
      const pegAreaHeight = height * 0.6;
      const randomColor = colors.ballColors[Math.floor(Math.random() * colors.ballColors.length)];
      
      let position = 0;
      for (let i = 0; i < rows; i++) {
        position += Math.random() < 0.5 ? 1 : 0;
      }
      
      const finalBin = position;
      const path = [];
      
      path.push({ x: width / 2, y: 0 });
      
      for (let i = 0; i < rows; i++) {
        const progress = i / rows;
        const targetX = (finalBin * columnWidth) + (columnWidth / 2);
        const currentX = width / 2 + (targetX - width / 2) * progress;
        
        const pegRow = pegPositions[i];
        let closestPegIndex = 0;
        let minDistance = Infinity;
        
        for (let j = 0; j < pegRow.xPositions.length; j++) {
          const distance = Math.abs(pegRow.xPositions[j] - currentX);
          if (distance < minDistance) {
            minDistance = distance;
            closestPegIndex = j;
          }
        }
        
        path.push({
          x: pegRow.xPositions[closestPegIndex],
          y: pegRow.y
        });
      }
      
      // [ALTERAÇÃO 2] Ponto final é a entrada da coluna (não o destino final)
      path.push({
        x: (finalBin * columnWidth) + (columnWidth / 2),
        y: pegAreaHeight + 5
      });
      
      return { 
        path, 
        index: 0, 
        t: 0, 
        bin: finalBin, 
        color: randomColor, 
        finished: false,
        falling: false,  // estado de queda na coluna
        fallY: 0,
        fallTargetY: 0
      };
    }

    function startSimulation() {
      simulationFinished = false;
      rows = parseInt(rowsInput.value, 10);
      totalBalls = parseInt(ballsInput.value, 10);
      totalBalls = Math.max(1, totalBalls);
      currentBall = 0;
      activeBalls = [];
      droppedBalls = 0;
      
      // Limpar resultado do teste anterior
      const resultDiv = document.getElementById('chi2-result');
      resultDiv.className = 'chi2-result';
      resultDiv.innerHTML = '';
      
      calculatePositions();
      
      const binCount = rows + 1;
      finishedBalls = Array(binCount).fill().map(() => []);
      finishedCounts = Array(binCount).fill(0);
      
      drawBoardStructure();
      
      if (spawnTimer) clearInterval(spawnTimer);
      
      const speedFactor = parseFloat(speedInput.value);
      const intervalMs = 300 / speedFactor;
      
      spawnTimer = setInterval(() => {
        if (currentBall < totalBalls) {
          const ball = generateBall();
          if (ball) {
            activeBalls.push(ball);
            currentBall++;
          }
        } else {
          clearInterval(spawnTimer);
        }
      }, intervalMs);
      
      requestAnimationFrame(animate);
    }

    function animate() {
      ctx.fillStyle = colors.background;
      ctx.fillRect(0, 0, width, height);
      
      drawBoardStructure();
      drawHistogram();
      
      const speedFactor = parseFloat(speedInput.value);
      const columnWidth = width / (rows + 1);
      const ballRadius = getBallRadius();
      const pegAreaHeight = height * 0.6;
      
      // [ALTERAÇÃO 2] Animar bolinhas que estão caindo nas colunas
      let fallingExists = false;
      for (let bin = 0; bin < finishedBalls.length; bin++) {
        const balls = finishedBalls[bin];
        if (!balls) continue;
        for (let i = 0; i < balls.length; i++) {
          const ball = balls[i];
          if (ball.currentY !== undefined && ball.currentY < ball.finalY) {
            ball.currentY += 4 * speedFactor;
            if (ball.currentY >= ball.finalY) {
              ball.currentY = ball.finalY;
            } else {
              fallingExists = true;
            }
          }
        }
      }
      
      for (let i = activeBalls.length - 1; i >= 0; i--) {
        const ball = activeBalls[i];
        const { path } = ball;
        
        if (!path || ball.index >= path.length - 1) {
          activeBalls.splice(i, 1);
          continue;
        }
        
        const p0 = path[ball.index];
        const p1 = path[ball.index + 1];
        
        ball.t += 0.05 * speedFactor;
        
        if (ball.t >= 1) {
          ball.t = 0;
          ball.index++;
          
          if (ball.index >= path.length - 1) {
            droppedBalls++;
            
            if (!finishedBalls[ball.bin]) {
              finishedBalls[ball.bin] = [];
            }
            
            // [ALTERAÇÃO 2] Calcular posição final e iniciar animação de queda
            const ballCount = finishedBalls[ball.bin].length;
            const row = Math.floor(ballCount / 2);
            const finalY = height - (ballRadius * 2) - (row * ballRadius * 2);
            
            finishedBalls[ball.bin].push({
              color: ball.color,
              currentY: pegAreaHeight + 6,  // começa no topo da coluna
              finalY: finalY                 // destino final
            });
            
            finishedCounts[ball.bin] = (finishedCounts[ball.bin] || 0) + 1;
            activeBalls.splice(i, 1);
            continue;
          }
        }
        
        const tt = ball.t;
        const cx = p0.x + (p1.x - p0.x) * tt;
        const cy = p0.y + (p1.y - p0.y) * tt;
        
        drawBall(cx, cy, ballRadius, ball.color);
      }
      
      if (activeBalls.length > 0 || currentBall < totalBalls || fallingExists) {
        requestAnimationFrame(animate);
      } else {
        // Verificação de contagem
        let totalInBins = 0;
        for (let bin = 0; bin < finishedBalls.length; bin++) {
          if (finishedBalls[bin]) {
            totalInBins += finishedBalls[bin].length;
          }
        }
        
        if (totalInBins !== totalBalls && droppedBalls === totalBalls) {
          let maxBin = 0;
          let maxCount = 0;
          for (let bin = 0; bin < finishedBalls.length; bin++) {
            if (finishedBalls[bin] && finishedBalls[bin].length > maxCount) {
              maxCount = finishedBalls[bin].length;
              maxBin = bin;
            }
          }
          
          const missing = totalBalls - totalInBins;
          for (let i = 0; i < missing; i++) {
            const ballCount = finishedBalls[maxBin].length;
            const row = Math.floor(ballCount / 2);
            const finalY = height - (ballRadius * 2) - (row * ballRadius * 2);
            finishedBalls[maxBin].push({
              color: colors.ballColors[Math.floor(Math.random() * colors.ballColors.length)],
              currentY: finalY,
              finalY: finalY
            });
          }
          
          drawHistogram();
        }
        
        drawBinomialCurve();
        runChiSquaredTest();
        simulationFinished = true;
      }
    }

    document.getElementById('generate').addEventListener('click', function() {
      // Parar qualquer simulação em andamento
      if (spawnTimer) {
        clearInterval(spawnTimer);
        spawnTimer = null;
      }
      
      // Zerar todas as variáveis de simulação
      activeBalls = [];
      finishedBalls = [];
      finishedCounts = [];
      currentBall = 0;
      droppedBalls = 0;
      totalBalls = 0;
      simulationFinished = false;
      
      // Limpar resultado do teste anterior
      const resultDiv = document.getElementById('chi2-result');
      resultDiv.className = 'chi2-result';
      resultDiv.innerHTML = '';
      
      calculatePositions();
      drawBoardStructure();
    });
    
    document.getElementById('start').addEventListener('click', startSimulation);
    
    window.onload = function() {
      initCanvas();
      calculatePositions();
      drawBoardStructure();
    };
  </script>
</body>
</html>
